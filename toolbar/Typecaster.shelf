<?xml version="1.0" encoding="UTF-8"?>
<shelfDocument>
  <!-- This file contains definitions of shelves, toolbars, and tools.
 It should not be hand-edited when it is being used by the application.
 Note, that two definitions of the same element are not allowed in
 a single file. -->

  <toolshelf name="Typecaster" label="Typecaster">
    <memberTool name="typecaster_installerGUI"/>
    <memberTool name="typecaster_convertFontNode"/>
    <memberTool name="typecaster_fontSelectionUI"/>
    <memberTool name="typecaster_localizeFontFiles"/>
  </toolshelf>

  <tool name="typecaster_installerGUI" label="Installer GUI" icon="PLASMA_App">
    <toolSubmenu>Typecaster/scripts</toolSubmenu>
    <script scriptType="python"><![CDATA[from typecaster import installer
installer.launch_gui()]]></script>
  </tool>

  <tool name="typecaster_convertFontNode" label="Convert Font to Typecaster Font" icon="PLASMA_App">
    <toolMenuContext name="network">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Typecaster/scripts</toolSubmenu>
    <script scriptType="python"><![CDATA[from __future__ import annotations
import hou
kwargs:dict 
    
def parm_from_parm(dst_parm:hou.Parm|hou.ParmTuple, src_parm:hou.Parm|hou.ParmTuple, src_index=None, dst_index=None):
    dst_is_tuple = isinstance(dst_parm,hou.ParmTuple)
    src_is_tuple = isinstance(src_parm,hou.ParmTuple)
    if dst_is_tuple and dst_index is not None:
        dst_parm:hou.Parm = dst_parm[dst_index]
        dst_is_tuple = False
    
    if src_is_tuple and src_index is not None:
        src_parm:hou.Parm = src_parm[src_index]
        src_is_tuple = False
    
    if src_is_tuple and dst_is_tuple:
        for i, dst_parm in enumerate(dst_parm):
            try:
                dst_parm.setFromParm(src_parm[i])
            except IndexError:
                pass
    elif not src_is_tuple and not dst_is_tuple:
        dst_parm.setFromParm(src_parm)
    else:
        raise Exception(f"Unexpected case for setfromparm! Destination: {dst_parm}, Source: {src_parm}")


for node in hou.selectedNodes():
    node : hou.OpNode
    if node.type().name() == "font":
        parent_node: hou.OpNode = node.parent()
        parms = {}
        parms['pack_method'] = 1
        parms['leading_follow_spacing'] = 1
        parms['glyph_remove_inline'] = 0
        triggercallback = ('file',)

        hole = node.evalParm('hole')
        if hole != 1:
            parms['hole_method'] = 3

        tcnode: hou.OpNode = parent_node.createNode(node_type_name='typecaster_font')
        pos = node.position()
        pos_shifted = list(pos)
        pos_shifted[0] += 1.0
        pos_shifted[1] -= 0.5
        tcnode.setParms(parms)
        
        parm_from_parm( dst_parm=tcnode.parm('file'), src_parm=node.parm('file'))
        parm_from_parm( dst_parm=tcnode.parm('text'), src_parm=node.parm('text'))
        parm_from_parm( dst_parm=tcnode.parm('halign'), src_parm=node.parm('halign'))
        parm_from_parm( dst_parm=tcnode.parm('valign'), src_parm=node.parm('valign'))
        parm_from_parm( dst_parm=tcnode.parm('fontsize'), src_parm=node.parm('fontsize'))
        parm_from_parm( dst_parm=tcnode.parm('lod'), src_parm=node.parm('lod'))
        parm_from_parm( dst_parm=tcnode.parm('addattrib'), src_parm=node.parm('addattrib'))
        
        parm_from_parm( dst_parm=tcnode.parmTuple('t'), src_parm=node.parmTuple('t'))
        parm_from_parm( dst_parm=tcnode.parmTuple('r'), src_parm=node.parmTuple('r'))
        parm_from_parm( dst_parm=tcnode.parmTuple('s'), src_parm=node.parmTuple('s'))
        
        parm_from_parm( dst_parm=tcnode.parm('tracking'), src_parm=node.parmTuple('tracking')[0])
        parm_from_parm( dst_parm=tcnode.parm('leading') , src_parm=node.parmTuple('tracking')[1])
        
        for tgt in triggercallback:
            parm: hou.Parm = tcnode.parm(tgt)
            parm.pressButton()
            
        if kwargs.get('shiftclick',False):
            for connection in node.outputConnections():
                connection:hou.NodeConnection
                outnode:hou.OpNode = connection.outputNode()
                # This basic system currently doesn't handle dots or any other
                # unusual network stuff and will only work to connect one
                # hou.OpNode to another hou.OpNode.
                if outnode:
                    outnode.setInput(connection.outputIndex(), tcnode, 0)
                else:
                    print(f"Failed to create a connection for {tcnode}")
            tcnode.setPosition(pos)
            node.setPosition(pos_shifted)
            
            nodename = f"{node.name()}"
            # nodename_old = f"{nodename}_old"
            # node.setName( nodename_old, unique_name=True)
            node.destroy()
            tcnode.setName( nodename, unique_name=True)
            
        else:
            tcnode.setPosition(pos_shifted)
            
            nodename = f"tc_{node.name()}"
            tcnode.setName( nodename, unique_name=True)]]></script>
  </tool>

  <tool name="typecaster_fontSelectionUI" label="Font Selector" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import hou

selection = hou.selectedNodes()

if len(selection)==1:
    from typecaster.fontUI import FontSelector
    FontSelector(hou.ui.mainQtWindow(), selection[0])
else:
    hou.ui.displayMessage("Please select exactly one node!", severity=hou.severityType.Warning)]]></script>
  </tool>

  <tool name="typecaster_localizeFontFiles" label="Localize Fonts Used" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import hou
from typecaster.fontUI import interpret_font_parms, swap_font_parms, PARMNAMING
from pathlib import Path
import shutil
import hashlib
import io
import json
import fnmatch

if hou.isUIAvailable():
    confirmed = hou.ui.displayConfirmation(text="Please confirm before running this operation",
                                        severity=hou.severityType.Warning,
                                        help="This operation will attempt to modify ALL Typecaster Font nodes\nin the project file to use a common font path local to the project.\nReverting back to font names can be challenging.",)
else:
    # If this script is being run in a non-graphical context, we can assume the user knows what they're doing and don't need confirmation.
    confirmed = True

if confirmed:
    
    foundtypes = []
    pattern = "Typecaster::typecaster_font::*"
    category = hou.sopNodeTypeCategory()
    for node_type_name, node_type in category.nodeTypes().items():
        if fnmatch.fnmatch(node_type_name, pattern):
            foundtypes.append(hou.nodeType(category, node_type_name))
    
    # foundnodes = hou.nodeType(hou.sopNodeTypeCategory(), "Typecaster::typecaster_font::1.0")

    immovable_fonts = {}
    fonts_to_move = {}

    projectvar = '$HIP'
    projectfontfolderstring = f"{projectvar}/fonts"
    projectfontfolder = Path(hou.text.expandString(projectfontfolderstring)).resolve()
    projectfontfolder.mkdir(exist_ok=True)


    def get_file_hash(file: Path, algorithm="sha256"):
        """Basice file hashing function using pathlib path objects."""
        h = hashlib.new(algorithm)

        # Use the interpreter's default buffer size for efficient reading
        chunk_size = io.DEFAULT_BUFFER_SIZE 

        with file.open('rb') as f:
            while chunk := f.read(chunk_size):
                h.update(chunk)
        return h.hexdigest()

    stats = {'bypassed':[],'modified':[],'already_local':[],'invalid':[]}

    with hou.undos.group("Localize Typecaster Fonts to project"):
        for foundtype in foundtypes:
            for node in foundtype.instances():
                node: hou.OpNode
                finfo = interpret_font_parms(node)
                if finfo.validfont:
                    # Only progress if the font being specified on the current node is valid
                    if finfo.info and (sourcetag := finfo.info.tags.get('source','') )in ('Adobe'):
                        # Current node was found to be using an adobe font. Probably best not to automate the collection of them.
                        immovable_fonts.setdefault(sourcetag,{}).setdefault(finfo.name, []).append(node.path())
                        stats['bypassed'].append(node.path())
                    else:
                        if not finfo.is_filepath:
                            # If not already a filepath, swap to one
                            swap_font_parms(node,2)

                        else:
                            if finfo.path.parent.resolve() == projectfontfolder:
                                # If the font is already a filepath and is in the project font folder,
                                # it has already been localized and doesn't need to be touched.
                                stats['already_local'].append(node.path())
                                continue

                        # By this point, we should only be operating on font nodes which are using distinct paths which weren't already pointed to the fonts folder
                        font_in_folder = projectfontfolder / finfo.path.name

                        if not font_in_folder.exists():
                            fonts_to_move[font_in_folder] = finfo.path

                        elif get_file_hash(finfo.path) != get_file_hash(font_in_folder):
                            # This gets triggered if there is a font with the correct name in the project foler,
                            # but it's hash doesn't match the current node's font file (EXTREMELY unlikely)
                            print(f"<TYPECASTER WARNING> The file [{finfo.path}] doesn't have the same contents as [{font_in_folder}]. An automatic fix will be used, but this is likely indicative of a corrupted font file  or bug which should be investigated.")
                            font_in_folder = projectfontfolder / f"{finfo.path.stem}_{node.name()}{finfo.path.suffix}"
                            fonts_to_move[font_in_folder] = finfo.path

                        pathparm:hou.Parm = node.parm(PARMNAMING['1.0']['font'])
                        if pathparm:
                            newpathstring = f"{projectfontfolderstring}/{font_in_folder.relative_to(projectfontfolder)}"
                            pathparm.set(newpathstring)

                        stats['modified'].append(node.path())
                else:
                    stats['bypassed'].append(node.path())

    # Move the designated fonts to the local folder
    for destination in fonts_to_move:
        source = fonts_to_move[destination]
        shutil.copy(source, destination)

    log = ("Ran Typecaster localization script with the following results:"
        f"\n    Nodes modified:      {len(stats['modified'])}"
        f"\n    Nodes already local: {len(stats['already_local'])}"
        f"\n    Nodes bypassed:      {len(stats['bypassed'])}")

    if hou.isUIAvailable():
        hou.ui.displayMessage(log,title='Typecaster',details_label='Show immovable font info',details=json.dumps(immovable_fonts, indent=4) if immovable_fonts else None)
    else:
        print(log)
]]></script>
  </tool>
</shelfDocument>
